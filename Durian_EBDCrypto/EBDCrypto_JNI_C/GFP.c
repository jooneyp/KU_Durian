#include "EBDerror.h"
#include "EBDCrypto.h"

SINT BN_abs_comp(BN *a,	BN *b);
SINT BN_asym_sub(BN *a, BN *b, BN *c);
SINT BN_add(BN *c, BN *a, BN *b);
SINT BN_sub(BN *c, BN *a, BN *b);
SINT BN_plain_mul(BN *c, BN *a, BN *b);
SINT BN_mod(BN *r, BN *a, BN *m);
SINT BN_mul_inv_mod(BN *b, BN *a, BN *m);
SINT BN_plain_sqr(BN *b, BN *a);

#define BN_mul(c,a,b) BN_plain_mul(c,a,b)
#define BN_sqr(c,a) BN_plain_sqr(c,a)

#define MAC_CLR_UPPER_ZEROBYTES(x) \
{ \
	ULONG *__pl; \
	for(__pl= &((x).dat[(x).len-1]); (x).len > 0; (x).len--) \
	if(*(__pl--)) break; \
	}

/*****************************/
/* GF(p) ���� modular ���� */
/*****************************/
/*******************************************************************************
* �� �� �� : GFP_add
*
* �Լ����� :
* *r - ��¹��� GF(p)�� ���� r�� ������
* *a - �Է¹��� GF(p)�� ���� a�� ������
* *b - �Է¹��� GF(p)�� ���� b�� ������
* *p - GF(p) ���� modular p�� ������
* Return :
* 0 - ����
*
*------------------------------------------------------------------------------
* �Լ����� : GF(p) ���� �� ���� a, b�� ���� ���� ���� �Լ� (r = a + b (mod p)),
�� ���� a, b�� 0 <= a < p , 0 <=b < p ������ �����ؾ� ��
*******************************************************************************/
SINT GFP_add(GFP *r, GFP *a, GFP *b, GFP *p)
{
	BN_add(r, a, b);
	if (BN_abs_comp(r, p) >= 0) {
		BN_asym_sub(r, r, p);
	}
	MAC_CLR_UPPER_ZEROBYTES(*r);
	return 0;
}
/*******************************************************************************
* �� �� �� : GFP_sub
*
* �Լ����� :
* *r - ��¹��� GF(p)�� ���� r�� ������
* *a - �Է¹��� GF(p)�� ���� a�� ������
* *b - �Է¹��� GF(p)�� ���� b�� ������
* *p - GF(p) ���� modular p�� ������
* Return :
* 0 - ����
*
*------------------------------------------------------------------------------
* �Լ����� : GF(p) ���� �� ���� a, b�� ���� ���� ���� �Լ� (r = a - b (mod p)),
�� ���� a, b�� 0 <= a < p , 0 <=b < p ������ �����ؾ� ��
*******************************************************************************/
SINT GFP_sub(GFP *r, GFP *a, GFP *b, GFP *p)
{
	BN_sub(r, a, b);
	if (r->sig == -1)
		BN_add(r, r, p);
	return 0;
}
/*******************************************************************************
* �� �� �� : GFP_mul
*
* �Լ����� :
* *r - ��¹��� GF(p)�� ���� r�� ������
* *a - �Է¹��� GF(p)�� ���� a�� ������
* *b - �Է¹��� GF(p)�� ���� b�� ������
* *p - GF(p) ���� modular p�� ������
* Return :
* 0 - ����
*
*------------------------------------------------------------------------------
* �Լ����� : GF(p) ���� �� ���� a, b�� ���� ���� ���� �Լ� (r = a * b (mod p)),
�� ���� a, b�� r�� ���� �ٸ� �����͸� ������ ��
*******************************************************************************/
SINT GFP_mul(GFP *r, GFP *a, GFP *b, GFP *p)
{
	BN_mul(r, a, b);
	BN_mod(r, r, p);
	return 0;
}
/*******************************************************************************
* �� �� �� : GFP_mul_inv
*
* �Լ����� :
* *r - ��¹��� GF(p)�� ���� r�� ������
* *a - �Է¹��� GF(p)�� ���� a�� ������
* *p - GF(p) ���� modular p�� ������
* Return :
* 0 - ����
*
*------------------------------------------------------------------------------
* �Լ����� : GF(p) ���� ���� a�� ���� ������ ���� ���� ���� �Լ�
(r = a^-1 (mod p)), ���� a�� r�� ���� �ٸ� �����͸� ������ ��
*******************************************************************************/
SINT GFP_mul_inv(GFP *r, GFP *a, GFP *p)
{
	BN_mul_inv_mod(r, a, p);
	return 0;
}
/*******************************************************************************
* �� �� �� : GFP_sqr
*
* �Լ����� :
* *r - ��¹��� GF(p)�� ���� r�� ������
* *a - �Է¹��� GF(p)�� ���� a�� ������
* *p - GF(p) ���� modular p�� ������
* Return :
* 0 - ����
*
*------------------------------------------------------------------------------
* �Լ����� : GF(p) ���� ���� a�� ���� ���� ���� �Լ�
(r = a^2 (mod p)), ���� a�� r�� ���� �ٸ� �����͸� ������ ��
*******************************************************************************/
SINT GFP_sqr(GFP *r, GFP *a, GFP *p)
{
	BN_sqr(r, a);
	BN_mod(r, r, p);
	return 0;
}