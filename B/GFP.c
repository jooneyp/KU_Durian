/********************************************************************************
* 파일설명 : GF(p) 상의 큰 수 연산 함수
********************************************************************************/
#include "KUCrypto2.h"
/*****************************/
/* GF(p) 상의 modular 연산 */
/*****************************/
/*******************************************************************************
* 함 수 명 : GFP_add
*
* 함수인자 :
* *r - 출력받을 GF(p)의 원소 r의 포인터
* *a - 입력받은 GF(p)의 원소 a의 포인터
* *b - 입력받은 GF(p)의 원소 b의 포인터
* *p - GF(p) 상의 modular p의 포인터
* Return :
* 0 - 성공
*
*------------------------------------------------------------------------------
* 함수설명 : GF(p) 상위 두 원소 a, b에 대한 덧셈 연산 함수 (r = a + b (mod p)),
두 원소 a, b는 0 <= a < p , 0 <=b < p 조건을 만족해야 함
*******************************************************************************/
SINT
	GFP_add(
	GFP *r,
	GFP *a,
	GFP *b,
	GFP *p
	)
{
	BN_add(r,a,b);
	if(BN_abs_comp(r,p) >= 0 ){
		BN_asym_sub(r,r,p);
	}
	MAC_CLR_UPPER_ZEROBYTES(*r);
	return 0;
}
/*******************************************************************************
* 함 수 명 : GFP_sub
*
* 함수인자 :
* *r - 출력받을 GF(p)의 원소 r의 포인터
* *a - 입력받은 GF(p)의 원소 a의 포인터
* *b - 입력받은 GF(p)의 원소 b의 포인터
* *p - GF(p) 상의 modular p의 포인터
* Return :
* 0 - 성공
*
*------------------------------------------------------------------------------
* 함수설명 : GF(p) 상위 두 원소 a, b에 대한 뺄셈 연산 함수 (r = a - b (mod p)),
두 원소 a, b는 0 <= a < p , 0 <=b < p 조건을 만족해야 함
*******************************************************************************/
SINT
	GFP_sub(
	GFP *r,
	GFP *a,
	GFP *b,
	GFP *p
	)
{
	BN_sub(r,a,b);
	if(r->sig == -1)
		BN_add(r,r,p);
	return 0;
}
/*******************************************************************************
* 함 수 명 : GFP_mul
*
* 함수인자 :
* *r - 출력받을 GF(p)의 원소 r의 포인터
* *a - 입력받은 GF(p)의 원소 a의 포인터
* *b - 입력받은 GF(p)의 원소 b의 포인터
* *p - GF(p) 상의 modular p의 포인터
* Return :
* 0 - 성공
*
*------------------------------------------------------------------------------
* 함수설명 : GF(p) 상위 두 원소 a, b에 대한 곱셈 연산 함수 (r = a * b (mod p)),
두 원소 a, b와 r은 서로 다른 포인터를 가져야 함
*******************************************************************************/
SINT
	GFP_mul(
	GFP *r,
	GFP *a,
	GFP *b,
	GFP *p
	)
{
	BN_mul(r,a,b);
	BN_mod(r,r,p);
	return 0;
}
/*******************************************************************************
* 함 수 명 : GFP_mul_inv
*
* 함수인자 :
* *r - 출력받을 GF(p)의 원소 r의 포인터
* *a - 입력받은 GF(p)의 원소 a의 포인터
* *p - GF(p) 상의 modular p의 포인터
* Return :
* 0 - 성공
*
*------------------------------------------------------------------------------
* 함수설명 : GF(p) 상위 원소 a에 대한 곱셈에 대한 역원 연산 함수
(r = a^-1 (mod p)), 원소 a와 r은 서로 다른 포인터를 가져야 함
*******************************************************************************/
SINT
	GFP_mul_inv(
	GFP *r,
	GFP *a,
	GFP *p
	)
{
	BN_mul_inv_mod(r,a,p);
	return 0;
}
/*******************************************************************************
* 함 수 명 : GFP_sqr
*
* 함수인자 :
* *r - 출력받을 GF(p)의 원소 r의 포인터
* *a - 입력받은 GF(p)의 원소 a의 포인터
* *p - GF(p) 상의 modular p의 포인터
* Return :
* 0 - 성공
*
*------------------------------------------------------------------------------
* 함수설명 : GF(p) 상위 원소 a에 대한 제곱 연산 함수
(r = a^2 (mod p)), 원소 a와 r은 서로 다른 포인터를 가져야 함
*******************************************************************************/
SINT
	GFP_sqr(
	GFP *r,
	GFP *a,
	GFP *p
	)
{
	BN_sqr(r,a);
	BN_mod(r,r,p);
	return 0;
}
